/**
 * NOTE:
 * Copy of @udecode/slate-plugins, with only one functional modification in function trimWhitespace.
 * Temporary hack for keeping newlines in code blocks.
 *
 * Rewrote function getNode after merge request comment:
 * https://gitlab.com/ontola/libro/-/merge_requests/61#note_413049754
 */
import { SlatePlugin } from '@udecode/slate-plugins-core';
import { ReactElement } from 'react';
import { renderToStaticMarkup } from 'react-dom/server';
import { Node as SlateNode, Text as SlateText } from 'slate';
import { RenderElementProps, RenderLeafProps } from 'slate-react';

// Remove extra whitespace generated by ReactDOMServer
const trimWhitespace = (rawHtml: string): string =>
  // rawHtml.replace(/(\r\n|\n|\r|\t)/gm, '');
  rawHtml;

// Remove redundant data attributes
const stripSlateDataAttributes = (rawHtml: string): string =>
  rawHtml
    .replace(/( data-slate)(-node|-type)="[^"]+"/gm, '')
    .replace(/( data-testid)="[^"]+"/gm, '');

/**
 * Remove all class names that are not starting with `slate-`
 */
const stripClassNames = (html: string) => {
  const allClasses = html.split(/(class="[^"]*")/g);

  let filteredHtml = '';
  allClasses.forEach((item, index) => {
    if (index % 2 === 0) {
      filteredHtml += item;

      return;
    }
    const slateClassNames = item.match(/(slate-[^"\s]*)/g);
    if (slateClassNames) {
      filteredHtml += `class="${slateClassNames.join(' ')}"`;
    }
  });

  return filteredHtml;
};

const getNode = (elementProps: RenderElementProps, plugins: SlatePlugin[]) => {
  // If no type provided we wrap children with div tag
  if (!elementProps.element.type) {
    return `<div>${elementProps.children}</div>`;
  }

  // Search for matching plugin based on element type
  const plugin = plugins.find((p) =>
    p.renderElement &&
    p.deserialize?.element?.some((item) => typeof item.type === 'string' && item.type === elementProps.element.type));

  if (plugin) {
    // Render element using picked plugins renderElement function and ReactDOM
    const html = renderToStaticMarkup(plugin.renderElement!(elementProps) as ReactElement);

    return stripClassNames(html);
  }

  if (plugins.some((p) => p.renderElement)) {
    return `<div>${elementProps.children}</div>`;
  }

  return undefined;
};

const getLeaf = (leafProps: RenderLeafProps, plugins: SlatePlugin[]) => {
  const { children } = leafProps;

  return plugins.reduce((result, plugin) => {
    if (!plugin.renderLeaf) {
      return result;
    }
    if (plugin.renderLeaf(leafProps) === children) {
      return result;
    }

    const newLeafProps = {
      ...leafProps,
      children: encodeURIComponent(result),
    };

    const html = decodeURIComponent(renderToStaticMarkup(plugin.renderLeaf(newLeafProps)));

    return stripClassNames(html);
  }, children);
};

/**
 *
 * @param plugins
 */
export const serializeHTMLFromNodes = (plugins: SlatePlugin[]) => (nodes: SlateNode[]): string => {
  const result = nodes
    .map((node: SlateNode) => {
      if (SlateText.isText(node)) {

        return getLeaf(
          {
            attributes: { 'data-slate-leaf': true },
            children: node.text,
            leaf: node as SlateText,
            text: node as SlateText,
          },
          plugins,
        );
      }

      return getNode(
        {
          attributes: { 'data-slate-node': 'element', 'ref': null },
          children: encodeURIComponent(serializeHTMLFromNodes(plugins)(node.children)),
          element: node,
        },
        plugins,
      );
    })
    .join('');

  return stripSlateDataAttributes(trimWhitespace(decodeURIComponent(result)));
};
